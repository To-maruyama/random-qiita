{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as ReactDom from 'react-dom';\nimport { Subject } from 'rxjs';\nimport { Store } from './Store';\nimport { getDescription } from './utils';\nimport { Notify } from './Notify';\nimport { createOutputStream } from './createOutputStream';\nimport { StateLogger } from './StateLogger';\n\nvar Registry = function () {\n  function Registry() {\n    this.nameCount = new Map();\n    this.displayNames = new Map();\n    this.storesMap = new Map();\n    this.stores = [];\n    this.initStreams();\n  }\n\n  Registry.prototype.reset = function () {\n    this.nameCount.clear();\n    this.displayNames.clear();\n    this.storesMap.clear();\n    this.stores = [];\n    this.initStreams();\n  };\n\n  Registry.prototype.getDisplayName = function (name) {\n    var description = getDescription(name);\n\n    if (!this.displayNames.has(name)) {\n      var count = this.nameCount.get(description) || 0;\n      count++;\n      this.nameCount.set(description, count);\n      var displayName = count > 1 ? description + \"#\" + count : description;\n      this.displayNames.set(name, displayName);\n    }\n\n    return this.displayNames.get(name);\n  };\n\n  Registry.prototype.getStore = function (name) {\n    if (!this.storesMap.has(name)) {\n      var store = new Store(name, this.getDisplayName(name));\n      this.storesMap.set(name, store);\n      this.stores.push(store);\n    }\n\n    return this.storesMap.get(name);\n  };\n\n  Registry.prototype.dispatch = function (action) {\n    var _this = this;\n\n    ReactDom.unstable_batchedUpdates(function () {\n      var e_1, _a, e_2, _b;\n\n      var notify = new Notify();\n      var stateLogger = null;\n\n      if (process.env.NODE_ENV === 'development') {\n        stateLogger = new StateLogger(_this.stores);\n      }\n\n      if (stateLogger) {\n        stateLogger.setState('prevState', _this.getState());\n      }\n\n      try {\n        for (var _c = tslib_1.__values(_this.stores), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var store = _d.value;\n          store.dispatch(action, notify);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      if (stateLogger) {\n        stateLogger.setState('nextState', _this.getState());\n        stateLogger.log(action);\n      }\n\n      try {\n        for (var _e = tslib_1.__values(notify.handlers), _f = _e.next(); !_f.done; _f = _e.next()) {\n          var fn = _f.value;\n          fn();\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      _this.input$.next(action);\n    });\n  };\n\n  Registry.prototype.getState = function () {\n    var e_3, _a;\n\n    var state = {};\n\n    try {\n      for (var _b = tslib_1.__values(this.stores), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var store = _c.value;\n\n        if (store.state !== undefined) {\n          state[store.displayName] = store.state;\n        }\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    return state;\n  };\n\n  Registry.prototype.initStreams = function () {\n    var _this = this;\n\n    this.input$ = new Subject();\n    this.output$ = createOutputStream(this.input$, this.stores);\n    this.output$.subscribe(function (action) {\n      _this.dispatch(action);\n    });\n  };\n\n  return Registry;\n}();\n\nexport { Registry };","map":null,"metadata":{},"sourceType":"module"}