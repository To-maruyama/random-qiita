{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { formatTime, getActionDescription } from './utils';\n\nvar StateLogger = function () {\n  function StateLogger(stores) {\n    this.stores = stores;\n    this.prevState = {};\n    this.nextState = {};\n    this.start = null;\n    this.end = null;\n  }\n\n  StateLogger.prototype.setState = function (type, state) {\n    if (type === 'nextState') {\n      this.end = Date.now();\n    }\n\n    this[type] = state;\n\n    if (type === 'prevState') {\n      this.start = Date.now();\n    }\n  };\n\n  StateLogger.prototype.log = function (action) {\n    var e_1, _a;\n\n    if (!this.end || !this.start) {\n      throw new Error('prev or next state not calculated');\n    }\n\n    var gray = 'color: gray; font-weight: lighter;';\n    var bold = 'font-weight: bold';\n    var boldBlue = 'font-weight: bold; color: blue';\n    var boldBlack = 'font-weight: bold; color: black';\n    var boldGray = 'font-weight: bold; color: gray';\n    var boldGreen = 'font-weight: bold; color: green';\n    var boldRed = 'font-weight: bold; color: red';\n    var actionType = getActionDescription(action.type);\n    var duration = (this.end - this.start).toFixed(2);\n    var time = formatTime(new Date(this.start));\n    var extraArgs = action.payload ? [action.payload] : [];\n\n    if (console.groupCollapsed) {\n      console.groupCollapsed.apply(console, tslib_1.__spread([\"%c action%c \" + actionType + \" %c@ \" + time + \" (in \" + duration + \" ms)%c\", gray, bold, gray, boldGreen], extraArgs));\n    } else {\n      console.log.apply(console, tslib_1.__spread([\"action  \" + actionType + \" @ \" + time + \" (in \" + duration + \" ms)\"], extraArgs));\n    }\n\n    console.log('%c prev state', boldGray, this.prevState);\n    console.log('%c action   ', boldBlue, action);\n    console.log('%c next state', boldGreen, this.nextState);\n\n    if (console.groupEnd) {\n      console.groupEnd();\n    }\n\n    try {\n      for (var _b = tslib_1.__values(this.stores), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var store = _c.value;\n        var key = store.displayName;\n\n        if (this.prevState[key] !== this.nextState[key]) {\n          if (console.group) {\n            console.group(\"%c   update %c \" + key, boldRed, boldBlack);\n          } else {\n            console.log(\"   update \" + key);\n          }\n\n          console.log('%c prev state', boldGray, this.prevState[key]);\n          console.log('%c next state', boldGreen, this.nextState[key]);\n        }\n\n        if (console.groupEnd) {\n          console.groupEnd();\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n\n  return StateLogger;\n}();\n\nexport { StateLogger };","map":null,"metadata":{},"sourceType":"module"}