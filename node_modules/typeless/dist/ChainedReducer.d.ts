import { AC, Flatten, ExtractPayload, Reducer } from './types';
export declare type OnHandler<S, T extends AC> = (state: S, payload: ExtractPayload<ReturnType<T>>, action: Flatten<ReturnType<T> & {
    type: string;
}>) => void;
export declare type ReplaceHandler<S, T extends AC> = (state: S, payload: ExtractPayload<ReturnType<T>>, action: Flatten<ReturnType<T> & {
    type: string;
}>) => S;
export declare type AttachFn<S> = {
    <T extends keyof S>(prop: T, fn: Reducer<S[T]>): ChainedReducer<S>;
    (fn: Reducer<S>): ChainedReducer<S>;
};
export declare class ChainedReducer<S> {
    private initial;
    private reducerMap;
    private defaultReducers;
    private reducer;
    constructor(initial: S);
    asReducer(): ChainedReducer<S> & Reducer<S>;
    attach<T extends keyof S>(fn: Reducer<S>): ChainedReducer<S> & Reducer<S>;
    attach<T extends keyof S>(prop: T, fn: Reducer<S[T]>): ChainedReducer<S> & Reducer<S>;
    replace<T extends AC>(actionCreator: T, fn: ReplaceHandler<S, T>): ChainedReducer<S> & Reducer<S>;
    mergePayload(actionCreators: AC): ChainedReducer<S> & Reducer<S>;
    nested<T extends keyof S>(prop: T, fn: (reducer: ChainedReducer<S[T]>) => ChainedReducer<S[T]>): ChainedReducer<S> & Reducer<S>;
    on<T extends AC>(actionCreator: T, fn: OnHandler<S, T>): ChainedReducer<S> & Reducer<S>;
    onMany<T extends AC, T2 extends AC>(actionCreator: [T, T2], fn: OnHandler<S, T | T2>): Reducer<S> & this;
    onMany<T extends AC, T2 extends AC, T3 extends AC>(actionCreator: [T, T2, T3], fn: OnHandler<S, T | T2 | T3>): Reducer<S> & this;
    private getReducer;
    private getReducers;
    private transform;
}
//# sourceMappingURL=ChainedReducer.d.ts.map