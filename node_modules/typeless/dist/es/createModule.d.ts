import { ChainedReducer } from './ChainedReducer';
import { Epic } from './Epic';
import { StateGetter } from './types';
export declare type Nullable<T> = T | null;
export declare type AnyFn = (...args: any[]) => any;
export declare type ConvertAC<T> = T extends null ? () => {} : T extends AnyFn ? T : never;
export declare type ActionCreators<T> = {
    [P in keyof T]: ConvertAC<T[P]>;
};
export declare type ActionMap = {
    [name: string]: Nullable<(...args: any[]) => {}>;
};
export interface HandleWithState<TState> {
    (): void;
    epic(): Epic;
    reducer(initialState: TState): ChainedReducer<TState>;
    reset(): void;
}
export interface Handle {
    (): void;
    epic(): Epic;
}
declare type ModuleBase = [Handle] & {
    withActions<T extends ActionMap>(actionMap: T): ModuleWithActions<ActionCreators<T>>;
    withState<TState>(): ModuleWithState<TState>;
};
declare type ModuleWithActions<TActions> = [Handle, TActions] & {
    withState<TState>(): ModuleWithActionsAndState<TState, TActions>;
};
declare type ModuleWithState<TState> = [HandleWithState<TState>, StateGetter<TState>] & {
    withActions<T extends ActionMap>(actionMap: T): ModuleWithActionsAndState<TState, ActionCreators<T>>;
};
declare type ModuleWithActionsAndState<TState, TActions> = [HandleWithState<TState>, TActions, StateGetter<TState>];
export declare function createModule(name: symbol): ModuleBase;
export {};
//# sourceMappingURL=createModule.d.ts.map