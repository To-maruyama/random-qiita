import * as tslib_1 from "tslib";
import { formatTime, getActionDescription } from './utils';
var StateLogger = (function () {
    function StateLogger(stores) {
        this.stores = stores;
        this.prevState = {};
        this.nextState = {};
        this.start = null;
        this.end = null;
    }
    StateLogger.prototype.setState = function (type, state) {
        if (type === 'nextState') {
            this.end = Date.now();
        }
        this[type] = state;
        if (type === 'prevState') {
            this.start = Date.now();
        }
    };
    StateLogger.prototype.log = function (action) {
        var e_1, _a;
        if (!this.end || !this.start) {
            throw new Error('prev or next state not calculated');
        }
        var gray = 'color: gray; font-weight: lighter;';
        var bold = 'font-weight: bold';
        var boldBlue = 'font-weight: bold; color: blue';
        var boldBlack = 'font-weight: bold; color: black';
        var boldGray = 'font-weight: bold; color: gray';
        var boldGreen = 'font-weight: bold; color: green';
        var boldRed = 'font-weight: bold; color: red';
        var actionType = getActionDescription(action.type);
        var duration = (this.end - this.start).toFixed(2);
        var time = formatTime(new Date(this.start));
        var extraArgs = action.payload ? [action.payload] : [];
        if (console.groupCollapsed) {
            console.groupCollapsed.apply(console, tslib_1.__spread(["%c action%c " + actionType + " %c@ " + time + " (in " + duration + " ms)%c",
                gray,
                bold,
                gray,
                boldGreen], extraArgs));
        }
        else {
            console.log.apply(console, tslib_1.__spread(["action  " + actionType + " @ " + time + " (in " + duration + " ms)"], extraArgs));
        }
        console.log('%c prev state', boldGray, this.prevState);
        console.log('%c action   ', boldBlue, action);
        console.log('%c next state', boldGreen, this.nextState);
        if (console.groupEnd) {
            console.groupEnd();
        }
        try {
            for (var _b = tslib_1.__values(this.stores), _c = _b.next(); !_c.done; _c = _b.next()) {
                var store = _c.value;
                var key = store.displayName;
                if (this.prevState[key] !== this.nextState[key]) {
                    if (console.group) {
                        console.group("%c   update %c " + key, boldRed, boldBlack);
                    }
                    else {
                        console.log("   update " + key);
                    }
                    console.log('%c prev state', boldGray, this.prevState[key]);
                    console.log('%c next state', boldGreen, this.nextState[key]);
                }
                if (console.groupEnd) {
                    console.groupEnd();
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    return StateLogger;
}());
export { StateLogger };
//# sourceMappingURL=StateLogger.js.map