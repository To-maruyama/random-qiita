import * as tslib_1 from "tslib";
import { queueScheduler, merge, empty, defer, from, of, } from 'rxjs';
import { mergeMap, observeOn, subscribeOn } from 'rxjs/operators';
import { logAction, isAction } from './utils';
function getHandlers(stores, action) {
    var _a = tslib_1.__read(action.type, 2), symbol = _a[0], type = _a[1];
    return stores
        .filter(function (store) {
        if (!store.isEnabled || !store.epic) {
            return false;
        }
        var _a = store.epic, handlers = _a.handlers, moduleHandlers = _a.moduleHandlers;
        return (moduleHandlers.has(symbol) ||
            (handlers.has(symbol) && handlers.get(symbol).has(type)));
    })
        .map(function (store) {
        var _a = store.epic, handlers = _a.handlers, moduleHandlers = _a.moduleHandlers;
        return tslib_1.__spread((handlers.has(symbol) && handlers.get(symbol).has(type)
            ? handlers.get(symbol).get(type)
            : []), (moduleHandlers.has(symbol) ? moduleHandlers.get(symbol) : [])).map(function (handler) { return ({ store: store, handler: handler }); });
    })
        .reduce(function (ret, arr) {
        ret.push.apply(ret, tslib_1.__spread(arr));
        return ret;
    }, []);
}
export function createOutputStream(action$, stores) {
    var deps = { action$: action$ };
    return action$.pipe(subscribeOn(queueScheduler), observeOn(queueScheduler), mergeMap(function (sourceAction) {
        var handlers = getHandlers(stores, sourceAction);
        if (!handlers.length) {
            return empty();
        }
        return merge.apply(void 0, tslib_1.__spread(handlers.map(function (_a) {
            var store = _a.store, handler = _a.handler;
            return defer(function () {
                var name = store.displayName;
                if (process.env.NODE_ENV === 'development') {
                    logAction(name, sourceAction);
                }
                var result = handler(sourceAction.payload, deps, sourceAction);
                if (Array.isArray(result)) {
                    return from(result);
                }
                if (isAction(result)) {
                    return of(result);
                }
                return result;
            }).pipe(mergeMap(function (action) {
                if (action === null) {
                    return empty();
                }
                if (action === undefined) {
                    console.error('Undefined action returned in epic.', {
                        action: action,
                        store: name,
                    });
                    return empty();
                }
                if (!isAction(action)) {
                    console.error('Invalid action returned in epic.', {
                        sourceAction: sourceAction,
                        action: action,
                        store: name,
                    });
                    return empty();
                }
                return of(action);
            }));
        })));
    }));
}
//# sourceMappingURL=createOutputStream.js.map