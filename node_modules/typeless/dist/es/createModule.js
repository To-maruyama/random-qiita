import * as tslib_1 from "tslib";
import { ChainedReducer } from './ChainedReducer';
import { Epic } from './Epic';
import * as React from 'react';
import { getIsHmr } from './onHmr';
import { useMappedState } from './useMappedState';
import { snakeCase } from './utils';
import { useRegistry } from './useRegistry';
export function createModule(name) {
    var hasState = false;
    var actions = null;
    var epic = null;
    var reducer = null;
    var store = null;
    var base = [createHandle()];
    base.withActions = withActions;
    base.withState = withState;
    getState._module = name.toString();
    getState._store = null;
    getState.useState = function () { return useMappedState([getState], function (state) { return state; }); };
    return base;
    function createHandle() {
        var handle = function () {
            var registry = useRegistry();
            store = registry.getStore(name);
            getState._store = store;
            React.useMemo(function () {
                store.enable({
                    epic: epic,
                    reducer: reducer,
                });
                if (!getIsHmr()) {
                    store.initState();
                    if (actions && actions.$init) {
                        registry.dispatch(actions.$init());
                    }
                }
            }, []);
            React.useEffect(function () {
                if (getIsHmr()) {
                    if (actions && actions.$remounted) {
                        registry.dispatch(actions.$remounted());
                    }
                }
                else {
                    if (actions && actions.$mounted) {
                        registry.dispatch(actions.$mounted());
                    }
                }
                return function () {
                    if (actions && actions.$unmounting) {
                        registry.dispatch(actions.$unmounting());
                    }
                    if (store) {
                        store.disable();
                    }
                    if (actions && actions.$unmounted) {
                        registry.dispatch(actions.$unmounted());
                    }
                };
            }, []);
        };
        handle.epic = function () {
            epic = new Epic();
            return epic;
        };
        handle.reducer = function (initialState) {
            var chained = new ChainedReducer(initialState);
            reducer = chained.asReducer();
            return reducer;
        };
        handle.reset = function () {
            epic = null;
            reducer = null;
            store = null;
        };
        return handle;
    }
    function createActions(actionMap) {
        actions = Object.keys(actionMap).reduce(function (acc, key) {
            var type = snakeCase(key).toUpperCase();
            acc[key] = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var ac = actionMap[key] || (function () { return ({}); });
                var action = ac.apply(void 0, tslib_1.__spread(args));
                action.type = [name, type];
                return action;
            };
            acc[key].getType = function () { return [name, type]; };
            return acc;
        }, {});
    }
    function withActions(newActionMap) {
        createActions(newActionMap);
        var ret = [createHandle(), actions];
        if (!hasState) {
            ret.withState = withState;
        }
        else {
            ret.push(getState);
        }
        return ret;
    }
    function withState() {
        hasState = true;
        var ret = [createHandle()];
        if (!actions) {
            ret.withActions = withActions;
        }
        else {
            ret.push(actions);
        }
        ret.push(getState);
        return ret;
    }
    function getState() {
        return store ? store.state : undefined;
    }
}
//# sourceMappingURL=createModule.js.map